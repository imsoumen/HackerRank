"""
To Heap or Not to Heap
----------------------------------
Link: https://www.hackerrank.com/contests/wissen-coding-challenge-2021/challenges/to-heap-or-not-to-heap
----------------------------------

Consider a rooted binary tree with n vertices containing numbers. Each vertex of the tree either has two sons (left son and right son), or no sons. We will call such a tree heap, if and only if for all vertices (except the root), the number assigned the vertex is smaller or equal to the parent's number.

Consider a heap and the following function:

dfs(vertex){
    print number in the vertex
    if (vertex is not a leaf) {
        dfs(left son of the vertex)
        dfs(right son of the vertex)
    }
}
You are given a sequence a[1..n] of n numbers. Your task is to calculate how many heaps will produce this sequence after calling dfs(root). It is guaranteed that the sequence is generated by generate() function listed in the input format section below. Since the number of heaps can be very large, output its value modulo 10^9+7.

Input Format

The first line contains a single odd integer n. The second line contains n space-separated integers a1,a2,a3,....,an - the result of dfs(root) call.

The sequence is generated by this algorithm:

int n, k, ptr
array of integers a[1 .. n]

generate(){
    read odd n
    create array val[1 .. n]
    for each i from 1 to n
        val[i] = random(1, n) //random(l, r) returns uniform integer from [l, r]
    ptr = 1
    sort array val by non-increasing
    gen_heap(val)
}

gen_heap(array values){
    k = size of values
    a[ptr] = values[1]
    ptr = ptr + 1
    if(k == 1)
        return
    create two empty arrays left, right
    for each i from 2 to k - 1
        if(random(1, 2) == 1){
            add values[i] to the end of left
        }else{
            add values[i] to the end of right
        }
    if(left has even size)
        add values[k] to the end of left
    else
        add values[k] to the end of right
    gen_heap(left);
    gen_heap(right);
}

Output Format

Output the number of heaps that will produce the given sequence modulo 10^9+7.

Sample Input

5
2 1 1 1 1

Sample Output

2

Explanation

There are two different heaps:

    2               2
   / \             / \
  1   1           1   1
     / \         / \
    1   1       1   1

"""



(Python Solution)

# Enter your code here. Read input from STDIN. Print output to STDOUT
import collections

mod = 10**9+7

catalan_cache = {}

def catalan(n):
    if n < 0:
        return 0
    if n <= 1:
        return 1
    if n in catalan_cache:
        return catalan_cache[n]
    top = 1
    for i in xrange(n + 1, n + n + 1):
        top = (top * i) % mod
    bottom = 1
    for i in xrange(1, n + 2):
        bottom = (bottom * i) % mod
    result = (top * pow(bottom, mod-2, mod)) % mod
    catalan_cache[n] = result
    return result

n = input()
a = map(int, raw_input().split())

bigger = [len(a)]*len(a)
back = [i-1 for i in xrange(len(a))]
for i in xrange(1, len(a)):
    ci = i-1
    while ci >=0 and a[ci] < a[i]:
        bigger[ci] = i
        ci = back[ci]
        back[i] = ci

grow_count = [0, 0]
c = 0
for i in xrange(1, n):
    if a[i-1] < a[i]:
        c += 1
    grow_count.append(c)

cache = collections.defaultdict(dict)

def count(a, start, finish):
    l = finish - start
    if l == 1:
        return 1
    
    if grow_count[finish] - grow_count[start] == 0:
        return catalan(l/2)
    
    if finish in cache[start]:
        return cache[start][finish]
    result = 0
    i = start + 2
    if bigger[start+1] < finish:
        i = bigger[start+1]
        if i-start & 1:
            return 0

    while i < finish:
        if bigger[start+1] < i:
            break
        if bigger[i] >= finish:
            if i-start-1 < finish-i:
                left = count(a, start + 1, i)
                if left:
                    result += left * count(a, i, finish) % mod
            else:
                right = count(a, i, finish )
                if right:
                    result += count(a, start + 1, i) * right % mod
        i += 2
    result %= mod
    cache[start][finish] = result
    return result

if bigger[0] < len(a):
    print 0
else:
    print count(a, 0, len(a))